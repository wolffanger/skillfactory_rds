import numpy as np

# Функция, реализующая функциональность угадывания

def game_core_v2(number):

# Задаём начальные значения переменных.
# count — счётчик попыток.
# predict: в первом цикле — число, по которому массив чисел делится надвое; (б) во втором — число, которое программа выдаёт в качестве догадки.
# lower_threshold — нижняя граница сужаемого с каждой итерацией (в первом цикле функции) пространства чисел, где ведётся поиск загаданного.
# upper_threshold — соответственно, верхняя граница.
# Начальное значение переменной predict = 50 (его может генерировать и рандомайзер, однако деление массива пополам статистически эффективнее).

    count = 0
    predict = 50
    division_number = predict
    lower_threshold = predict - predict
    upper_threshold = predict * 2

# Цикл задаёт число итераций, с каждой из которых происходит сужения зоны поиска в исходном пространстве чисел. Здесь таковых четыре. 
# Для меня остался открыт вопрос, считать ли попытко угадывания определение того, больше или меньше линии отсечки (division_number) загаданное число.
# В образце кода внутри модуля такая проверка попыткой не является. Соответственно, не считал серию таких проверок за попытку и я.
# Однако в первом цикле легко реализовать функциональность увеличения счётчика попыток с каждой такой проверкой.

    for i in range(0,4):

# Если «линия раздела» (division_number) попала ровно на загаданное число, миссия завершена. Счётчик фиксирует одну попытку, функция возвращает 1.

        if division_number == number: 
            count += 1
            return(count)
            break

# Если заданное число лежит выше линии раздела, линия раздела становится нижним порогом нового пространства поиска.
# Новая линия раздела фиксируется по середине (или на единицу ниже, при нечётном делимом) суженного пространества поиска. 

        if number > division_number:
            lower_threshold = division_number
            division_number = int(lower_threshold + ((upper_threshold - lower_threshold) // 2))

# Если заданное число лежит ниже линии раздела, линия раздела становится верхним порогом нового пространства поиска.

        elif number < division_number:
            upper_threshold = division_number
            division_number = int(lower_threshold + ((upper_threshold - lower_threshold) // 2))

# Если программа не угадала число в первом цикле, запускается второй.
# Бинарный поиск позволяет обойтись без нижеследующего куска кода (при i = 6), однако мне хотелось, чтобы программа могла сочетать методы перебора.
# Когда циклы деления массива чисел надвое заканчиваются, по оставшемуся пространству поиск ведётся с шагом в единицу.
# Predict увеличивается на единицу, каждый такой прирост расчитывается за попытку.
# Когда число угадано, функция возвращает число попыток.

    for predict in range(lower_threshold, upper_threshold + 1):
        count+=1
        if predict != number:
            continue
        else:
            return(count)
            break

#Функция, которая осуществляет запуск игры n (size) раз с заданными псевдослучайными загадываемыми числами.

def score_game(game_core):
    count_ls = []
    np.random.seed(1)
    random_array = np.random.randint(1,101, size=(1000))
    for number in random_array:
        count_ls.append(game_core(number))
    score = int(np.mean(count_ls))
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток")
    return(score)


#Вызов функции, инициирующей запуск игры заданное число раз.
score_game(game_core_v2)